## 分库分表的基本思想

sharding的基本思想就是把一个数据库切分成多个部分放到不同的数据库上面，
从而解决单一的数据库的性能问题（数据量的增多和访问量越来越大会导致IO 磁盘 内存 CPU计算能力出现瓶颈）

<li>所以其实对于大部分的数据库而言如果是以为table数量过多，那么可以简单粗暴地
进行垂直切分，把相对关系紧密的数据表分到一个数据库里面去。

<li>对于另外一种情形就是数据table的数量不是很多，但是table的记录太多了,就会考虑使用 '水平切分'
即把表的数据根据某种规则切分到不同的多个数据库当中去。

* 现实的情况是通常情况下两者是混合在一起使用的时候切分策略会发生一些微妙的关系。

        举例说明：当只考虑垂直切分的时候，划分到一起的表呢可以保持任意的关联关系。所以你可以按照功能模块
        来划分表格。但是一旦引入了水平切分之后标间之间的关联关系就会收到很大的制约。通常只允许有一个主表
        和多个次表之间保留关联关系。（按照这个主表的Id进行散列）也就是说：当同时进行垂直和水平切分时，
        在垂直方向上的切分将不再以“功能模块”进行划分，而是需要更加细粒度的垂直切分，
        而这个粒度与领域驱动设计中的“聚合”概念不谋而合，甚至可以说是完全一致，每个shard的主表正是一个聚合中的聚合根！
        这样切分下来你会发现数据库分被切分地过于分散了（shard的数量会比较多，但是shard里的表却不多），
        为了避免管理过多的数据源，充分利用每一个数据库服务器的资源，可以考虑将业务上相近，
        并且具有相近数据增长速率（主表数据量在同一数量级上）的两个或多个shard放到同一个数据源里，
        每个shard依然是独立的，它们有各自的主表，并使用各自主表ID进行散列，
        不同的只是它们的散列取模（即节点数量）必需是一致的.
                                     

## 分库分表需要解决的问题

1. 事务问题

        解决事务问题目前有两种可行的方案：
        分布式事务和通过应用程序与数据库共同控制实现事务
        下面对两套方案进行一个简单的对比。

* 分布式事务

优点： 交由数据库管理，简单有效
缺点：性能代价很高，特别是shard越来越多的时候（主要是二段提交需要统计所有的数据库的事务状态）

* 由应用程序和数据库共同控制

原理：将一个跨数据库的分布式事务分拆成多个仅处于单个数据库上面的小事务，并通过应用程序来总控制
各个小事务。

优点：性能上有优势

缺点：需要应用程序在事务控制上做灵活设计。如果使用了spring的事务管理那么该动起来相当复杂；


### 2.跨节点的join问题

只要是进行切分，跨节点Join的问题是不可避免的。
但是良好的设计和切分却可以减少此类情况的发生。
解决这一问题的普遍做法是分两次查询实现。
在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。

### 3.跨节点的count, order by,group by 以及聚合函数的问题

这是一类问题，他们都需要基于全部的数据集合进行计算（即全量数据中进行计算）。多数的代理都不会自动进行合并
处理。

* 解决方案： 与解决跨节点join问题累死，分别在各个节点上能得结果 然后在应用程序哪里进行合并。
和join不同的是每个节点的查询可以并行执行，因此很多时候他的速度比单一查一个大表快很多。但是如果结果集很大
对应用程序来说内存消耗是一个问题。


这就是说其实fork join框架类似，像各个子系统处理 然后汇总到应用上面进行一个
合并的处理和运算


### 4.数据迁移 容量规划 扩容等问题

来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）
来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，
同时对扩容规模和分表数量都有限制。
总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，
这也从一个侧面反映出了Sharding扩容的难度。

### 5. 事务
    参考： [关于分布式事务、两阶段提交、一阶段提交、Best Efforts 1PC模式和事务补偿机制的研究]
    (http://blog.csdn.net/bluishglc/article/details/7612811)


#### 分布式事务

####优点

1. 基于两阶段提交，最大限度的保证了跨数据库操作的原子性，是分布式系统下最严格的事务实现方式。

2. 实现简单，工作量小。 由于多数应用服务器以及一些独立的分布式事务协调器做了大量的封装工作，使得项目
当中引入分布式事务的难度和工作量基本上可以忽略不计。

#### 缺点
系统“水平”伸缩的死敌。基于两阶段提交的分布式事务在提交事务时需要在多个节点之间进行协调,
最大限度地推后了提交事务的时间点，客观上延长了事务的执行时间，这会导致事务在访问共享资源时发生冲突和死锁的概率增高，
随着数据库节点的增多，这种趋势会越来越严重，从而成为系统在数据库层面上水平伸缩的"枷锁"， 这
是很多Sharding系统不采用分布式事务的主要原因。

##### 基于 best effors 1PC 的模式的事务

待定

参考spring-data-neo4j的实现。鉴于Best Efforts 1PC模式的性能优势，
以及相对简单的实现方式，它被大多数的sharding框架和项目采用

#### 事务补偿（幂等值）

对于那些对性能要求很高，但对一致性要求并不高的系统，
往往并不苛求系统的实时一致性，只要在一个允许的时间周期内达到最终一致性即可，
这使得事务补偿机制成为一种可行的方案。
事务补偿机制最初被提出是在“长事务”的处理中，
但是对于分布式系统确保一致性也有很好的参考意义。
笼统地讲，与事务在执行中发生错误后立即回滚的方式不同，
事务补偿是一种事后检查并补救的措施，
它只期望在一个容许时间周期内得到最终一致的结果就可以了。
事务补偿的实现与系统业务紧密相关，并没有一种标准的处理方式。
一些常见的实现方式有：
对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步，等等。

### 6.ID问题
    一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。
    一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；
    另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由.
    一些常见的主键生成策略如下
    
* UUID
    
    使用UUID作主键是最简单的方案，但是缺点也是非常明显的。
    由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，
    在建立索引和基于索引进行查询时都存在性能问题


* 结合数据库维护一个Sequence表

此方案的思路也很简单，在数据库中建立一个Sequence表

每当需要为某个表的新纪录生成ID时就从Sequence表中取出对应表的nextid,
并将nextid的值加1后更新到数据库中以备下次使用。
此方案也较简单，
但缺点同样明显：由于所有插入任何都需要访问该表，该表很容易成为系统性能瓶颈，
同时它也存在单点问题，一旦该表数据库失效，整个应用程序将无法工作。
有人提出使用Master-Slave进行主从同步，但这也只能解决单点问题，
并不能解决读写比为1:1的访问压力问题。

* twitter的snowflake算法 生成自增的Id



####7.跨分片的排序问题（分页问题）
一般来讲，分页时需要按照指定字段进行排序。
当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，
而当排序字段非分片字段的时候，情况就会变得比较复杂了。

为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，
并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。

分页导致必须每个数据分片上都要做相同的运算，第一页运算量最小，随着页数的增加运算量越来越大。

解决方法：

* 如果是在前台应用提供分页，则限定用户只能看前面n页，这个限制在业务上也是合理的，
一般看后面的分页意义不大（如果一定要看，可以要求用户缩小范围重新查询）。

* 如果是后台批处理任务要求分批获取数据，则可以加大page size，
比如每次获取5000条记录，有效减少分页数（当然离线访问一般走备库，避免冲击主库）

* 分库设计时，一般还有配套大数据(Hadoop Hbase)平台汇总所有分库的记录，有些分页查询可以考虑走大数据平台。


### 8、分库策略

* 根据数值范围，比如用户Id为1-9999的记录分到第一个库，10000-20000的分到第二个库，以此类推。
* 根据数值取模，比如用户Id mod n，余数为0的记录放到第一个库，余数为1的放到第二个库，以此类推。


### 9. 分库数量


### 10、 路由透明

分库从某种意义上来说，意味着DB schema改变了，必然影响应用，
但这种改变和业务无关，所以要尽量保证分库对应用代码透明，
分库逻辑尽量在数据访问层处理。
当然完全做到这一点很困难，具体哪些应该由DAL负责，哪些由应用负责，这里有一些建议：


    对于单库访问，比如查询条件指定用户Id，则该SQL只需访问特定库。
    此时应该由DAL层自动路由到特定库，当库二次分裂时，也只要修改mod 因子，应用代码不受影响。




    对于简单的多库查询，DAL负责汇总各个数据库返回的记录，此时仍对上层应用透明。













https://www.jianshu.com/p/32b3e91aa22c





 






