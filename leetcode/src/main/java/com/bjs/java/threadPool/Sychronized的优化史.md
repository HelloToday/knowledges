



## 起初，为了解决多线程的问题，jvm说要有同步 于是诞生了Synchronized.

最早的synchronized是基于监视器 monitor的，对于加了synchronized修饰的方法 或者代码块进行反编译，可以发现生成的汇编码里面有明显的monitor enter和monitor exit这样的方法。

* 加锁阶段

  * 尝试获取monitor的锁 如果锁的进入数为0 ，那么获取锁，并且对锁进入数+1 操作
  * 本线程的另外的方法尝试获取该所，能够获取成功，不过是将数量+1 而已
  * 其他线程获取锁的时候进入阻塞状态，等待monitor的进入数变为0；

* 解锁阶段

  * monitor的进入数减1，如果减1后进入数为0，那线程退出monitor



## 后来程序员说，你这么基于操作系统的切换状态，效率很低呀，于是对synchronized关键字进行了优化

问题：由于monitor监视器锁的操作是基于操作系统的底层Mutex Lock实现的，对所要加锁线程加上互斥锁，但是加锁时间相比其他指令就长很多了，因此将这种基于互斥锁的加锁机制成为**重量级锁**。



### 补充知识_01 java的对象的结构

![java对对象的结构](.\java对对象的结构.png)Java的对象是创建在堆上的，指向堆的引用才放在栈上，而在堆上创建的对象结构大致是这样的.其中对象头就是用于保存对象的信息，包括哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，在不同状态下对象头存储的内容不同。

![java对象头](.\java对象头.png)态的情





文章来源：https://blog.csdn.net/liujia110/article/details/56484933





## 注意点

1. 注意不要锁字符串，字符串存储在常量池里面。

2. **避免被锁定的对象引用发生改变**