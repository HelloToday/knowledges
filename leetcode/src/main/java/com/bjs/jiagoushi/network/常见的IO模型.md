### BIO NIO和AIO

https://www.cnblogs.com/diegodu/p/6823855.html

IO 是操作系统的用户态和内核态之间进行交互的一种消耗比较大的操作。

    BIO，同步阻塞式IO，简单理解：一个线程处理一个连接，发起和处理IO请求都是同步的
    NIO，同步非阻塞IO，简单理解：一个线程处理多个连接，发起IO请求是非阻塞的但处理IO请求是同步的
    AIO，异步非阻塞IO，简单理解：一个有效请求一个线程，发起和处理IO请求都是异步的


###长久以来分不清阻塞和异步之间的关系 现在整理如下？

首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作，
同步IO和异步IO的区别就在于第二个步骤是否阻塞，
如果实际的IO读写阻塞请求进程，那么就是同步IO，
因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，

如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，
那么就是异步IO。

------

阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，
如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，
那么就是非阻塞IO。

### IO 的进化过程

* BIO

最原始的模型 每个请求都要新建一个线程

缺点：新建线程需要大的内存空间  操作系统允许的线程数量是有上限的；

* NIO

NIO本身是基于**事件驱动思想**来完成的，
其主要想解决的是BIO的大并发问题： 在使用同步I/O的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，
就必须使用多线程来处理。也就是说，将每一个客户端请求分配给一个线程来单独处理。
这样做虽然可以达到我们的要求，但同时又会带来另外一个问题。
由于每创建一个线程，就要为这个线程分配一定的内存空间（也叫工作存储器），
而且操作系统本身也对线程的总数有一定的限制。
如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客户端的请求，
甚至服务器可能会因此而瘫痪。

NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，
应用再将流读取到缓冲区或写入操作系统。 
也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，
当连接没有数据时，是没有工作线程来处理的。

**缺点：注意：在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，
但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，
从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。**

* AIO 

与NIO不同，操作系统负责处理内核区/用户区的内存数据迁移和真正的IO操作，
应用程序只须直接调用API的read或write方法即可。
这两种方法均为异步的，对于读操作而言，当有流可读取时，
操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；
对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。 
即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数