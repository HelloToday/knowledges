### 1. 校验工单状态

#### 	1.1 查询工单

​		

```sql
SELECT * from t_lon_application t  where t.APP_ID =?
```

查询工单是否是出于F0220（待签合同的状态）

校验t.channelId是否为空

### 2. 初始化参数

入参是 1中查询出来的实体类 t

#### 2.1  检验申请金额是否为空（t.appayAmt）

申请金额为空的时候替换为t.approveAmt（审批金额）

#### 	2.2 检验合同编号

​	

```sql
### 查询序列号
SELECT SEQ_NO+1 AS NEXT_VAL FROM T_SYS_CONTRACT_CODE t where SALE_CHANNEL=1

###利用数据库里面的值保存了当前最新的数值
select * from T_SYS_CONTRACT_CODE

```

​	如果为空则生成 编号 渠道id+日期（精确到天如：20160304）+6位顺序号递增（这个方法锁的范围太大了，有没有并发问题，另外魔术值尽量用枚举，另外生成合同编号的逻辑考虑可以考虑优化）

​	**t_lon_application 持久化合同号到这个表里面**

#### 2.3 查询扩展表

​	

```sql
SELECT * from  t_lon_application_ext t where t.APP_ID=?
```

1. 获取什么信息？

#### 2.4 dubbo调用贷前服务

联系人表，汽车，房产，房抵信息

#### 2.5 账户信息(银行卡信息)

```sql
####这个表连存的是银行卡和个人信息
select * from t_lon_account where APP_ID = #{appId} and VALID = 1
```



#### 2.6 设置费用信息

```sql
   select  *  from t_loan_fee_info    where APP_ID = #{appId} 
```

​	

#### 2.7 试算步骤

1. 获取分期费用
2. 获取还款计划列表

### 3  构建扩展参数

1. 查询银行卡信息

```sql
####这个表连存的是银行卡和个人信息 
####appId={appId}, accType="B6801", trusteeType="B134003" 还款实体卡
####appId, "B6802", "B134003"放款实体卡
select * from t_lon_account where APP_ID = #{appId} and VALID = 1 and appId={appId}, and  accType="B6801" and trusteeType="B134003"
```

2. 被保险人信息（机构）

   缓存查询资金渠道信息"BASE.T_FUND_CHANNEL_CONFIG."+channelId

### 4. 构建关联关系

#### 4.1 非P2P对应的关系

 "CLC01","PC01","CCA01","ECBS01"

#### 4.2获取合同模板的配置信息

##### 4.2.1 CLC01 渠道借款类

业务意义：

1.  从缓存当中查询key="BASE.T_CHANNEL_PRD_RELATION_PRODUCT_CONTRACT."+channelCode+"."+productId产品里面配置的合同号
2. 同二

##### 4.2.2 渠道征信授权书

业务意义:

1. 从缓存系统获取产品合同配置根据channel 和producntId,查询的key为"BASE.T_CHANNEL_PRD_RELATION_PRODUCT_CONTRACT."+channelCode+"."+productId;

   可以得到一个产品可以对应多少个合同模板

2. 从缓存当中查询所有的模板信息key=BASE.T_PRD_CONT_CONTRACT_TEMPLATE，结果为集合templates

3. templates当中筛选种类为授信类（B19901）的模板集合templates2

4. 基于templates2和工单生成对应关系

   createContractInfo(appId, templates2[i], Constants.Contract.COMMON_FALSE)

   4.1 首先检查对应关系是否存在

   ```sql
   	select * from t_lon_application_contract where app_id = {}
   ```

   4.2 如果上述检查 不存在该对应关系则生成之

##### 4.2.3 其他类型 （担保）生成

业务意义：保险公司提供担保么？

1. 查询工单保障信息 根据t.app_Id,结果是一个集合

   ```sql
   select t.guara_company_code from t_mls_loan_safeguard_info t where t.app_id = {}
   ```

2. 存在冗余参数**channel，productId** 知识根据app_id查询了保险公司代码

3. 根据保险公司代码 ，查询要签署的合同（desc ||id）

   ```sql
   #####这个表在另外的库里面
   select * from t_mls_contract_create_sub_rule   where SUB_CODE_TYPE in(	###1)
   	and IS_VALID='Y'
   ```

4. 缓存系统获取所有合同模板信息 **BASE.T_PRD_CONT_CONTRACT_TEMPLATE**

5. 查询合同id所对应的合同的详细信息

#####  4.2.4 公用合同生成

义务意义：

1. 从基础平台获取合同模板by productId（json array）

2. 遍历合同模板 合同模板id，合同名称，合同id，合同类型，是否通用

   **冗余判断存在--考虑优化**

3. 存在冗余参数***channel***

### 5 生成PDF

#### 5.1 生成合同临时保存路径

1. strRealPathPdf读取配置文件 path+工单号作为一个目录

#### 5.2 解析合同模板，填充占位符

1. ##### 下载合同根据 **模板UUID**

2. ##### 取得body里面的${} node

   ```java
   //包含某个值，字段 B12302
   boolean flag = sourceStrArray.contains(GenericUtil.basePlatform.FIELD);
   //包含某个值，函数B12303
   boolean function = sourceStrArray.contains(GenericUtil.basePlatform.FUNCTION);
   //标准码B12304
   boolean BZM = sourceStrArray.contains(GenericUtil.basePlatform.BZM);
   //费用转化大写B12305
   boolean DX = sourceStrArray.contains(GenericUtil.basePlatform.DX);
   //百分百B12306
   boolean BFB = sourceStrArray.contains(GenericUtil.basePlatform.BFB);
   ```

   * 2.1  	 判断是否包含字符来决定如何取值 
   * 以@符号分割，分割后包含一个“KEY___VAVLUE”的数组
   * 解析上面的“KEY___VAVLUE”数组，实例如下

   ``{scale=18, name=certId, type=B12501, gettype=B12302, roundmode=B12401}``

   * **注意这里面有个循环遍历的代码 ，非常的不需要** 实际上就是取值 代码中定义了几个业务意义

     ```text
     super--- 代表超级模板号
     scale--- 数值精度
     name--- database
     roundmode 四舍五入的保留方式
     bzm---标准码
     gettype ---废弃
     field---首字母大写的字段值
     shop -- 商品信息
     contact --联系人参数
     ```



   * *super*如果超**超级标准码参数不为空**根据工单ID调用贷前接口，扩展模板信息** 查询key = superParmas 这个值 ；如果superParmas包含“firstStageRepayAmt” or  “lastRepayAmt” 则拼接字符串

   * *shop* 调用贷前 查询商品信息 如果查询的商品的数量比传入的数量大 返回最新的一条（获取比传入的商品更加新的一个商品）

   * **contact** 取配偶 家庭成员或其他联系人 如果传入的为空则从工单列表当中读取数据初始化那些数据。**这里是个递归调用 作用就是按照优先级 配偶>家庭成员>普通联系人的顺序返 联系人**


   * database--->取工单实体的那个字段 **getdataBase **这样的一个invoke() 来去的里面的值

   3. ##### 函数去取值方式

      [ 参考另外一篇文章](./函数取值方式.md)

   4. ##### 标准码 取值

      >取缓存当中的标准码
      >
      >

   5. ##### 费用转大写




